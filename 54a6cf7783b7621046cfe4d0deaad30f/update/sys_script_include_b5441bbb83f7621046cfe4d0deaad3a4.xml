<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>global.DocuGenLLMClientUtils</api_name>
        <caller_access/>
        <client_callable>true</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>DocuGenLLMClientUtils</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/**
 * DocuGenLLMClientUtils with Predictive Maintenance Suggestions
 * Analyzes script changes and suggests documentation/annotation updates
 * Designed for ServiceNow scripts (Client Scripts, Script Includes, Scheduled Scripts)
 */

var DocuGenLLMClientUtils = Class.create();
DocuGenLLMClientUtils.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {
    initialize: function(model) {
		let ifLayer = null;
        const docuGenModel = new GlideRecord('u_docugen_models');
        if(!model) {
			ifLayer = 'not model';
			docuGenModel.addQuery('u_default', true);
		} else if(model.match(/[a-z0-9]{32}/)) {
			ifLayer = 'match sys_id'; 		
			docuGenModel.addQuery('sys_id', model);
		} else {
			ifLayer = 'model name';
			docuGenModel.addQuery('u_name', model);		
		}
		docuGenModel.query();
		
        if(!docuGenModel.next()) {
			gs.error(`[DocuGenLLMClientUtils.initialize] Error: Model ${model} not found in the u_docugen_models table. If Layer: ${ ifLayer }`);
            throw new Error(`[DocuGenLLMClientUtils.initialize] Error: Model ${model} not found in the u_docugen_models table.`);
        } else {
			// Model Globals
			this.LLMENDPOINT = docuGenModel.u_api_endpoint;
			this.APIKEY = docuGenModel.u_api_key.getDecryptedValue();
			this.APIPROMPT = docuGenModel.u_prompt;
			this.PROMPTATTRIBUTE = docuGenModel.u_prompt_text_attribute;
			this.MODEL = docuGenModel.u_model.toString();
			this.MODEL_SYS_ID = docuGenModel.getUniqueValue();
		}
	
		// Logging Globals
		this.LOG_SOURCE = 'DocuGenLLM';
		this.REQUEST_TYPE = '';
		this.LOG_MESSAGE = '';
		this.LOG_LEVEL = 0;

		// Table Globals
        this.DOCS_TABLE = 'u_docugen_code_docs';
        this.SUGGESTIONS_TABLE = 'u_docugen_suggestions';
        
		// Debug Global
		this.DEBUG = false;
    },

    STATUS: {
        SUCCESS: 200,
        BAD_REQUEST: 400,
        DEBUG: 999
    },

    generateAnnotation: function(recordSysId, recordDisplayValue, tableName) {
        this.REQUEST_TYPE = 'annotation';
        let responseArr = [];

        try {
            const prompt = this._buildAnnotationPrompt(recordSysId, tableName);
            const jsonFormattedPrompt = this._formatRequest(prompt);

            if (this.DEBUG) responseArr.push(jsonFormattedPrompt);

            const response = this._callLLMAPI(jsonFormattedPrompt);
            if (this.DEBUG) responseArr.push(response);

            const annotation = this._parseLLMAnnotationResponse(response);
            if (this.DEBUG) responseArr.push(annotation);

            const result = this._storeAnnotation(annotation, recordSysId, tableName, recordDisplayValue);
            if (this.DEBUG) responseArr.push(result);

            if (this.DEBUG) return this._createResponse(this.STATUS.DEBUG, responseArr);

            this.LOG_MESSAGE = JSON.stringify(response);
            this._writeUsageLog();
            return this._createResponse(this.STATUS.SUCCESS, result);
        } catch (e) {
            this.LOG_MESSAGE = `[DocuGenLLM.generateAnnotation] Error: ${e}`;
            this.REQUEST_TYPE = 'annotation';
            this._writeUsageLog();
            return this._createResponse(this.STATUS.BAD_REQUEST, `[DocuGenLLM.generateAnnotation]: ${e}`);
        }
    },

    generateDocumentation: function(recordSysId, recordDisplayValue, tableName) {
        this.REQUEST_TYPE = 'documentation';
        let responseArr = [];

        try {
            const prompt = this._buildDocumentationPrompt(recordSysId, tableName);
            const jsonFormattedPrompt = this._formatRequest(prompt);

            if (this.DEBUG) responseArr.push(jsonFormattedPrompt);

            const response = this._callLLMAPI(jsonFormattedPrompt);
            if (this.DEBUG) responseArr.push(response);

            const documentation = this._parseLLMDocumentResponse(response);
            if (this.DEBUG) responseArr.push(documentation);

            const result = this._storeDocumentation(documentation, recordSysId, tableName, recordDisplayValue);
            if (this.DEBUG) responseArr.push(result);

            if (this.DEBUG) return this._createResponse(this.STATUS.DEBUG, responseArr);

            this.LOG_MESSAGE = JSON.stringify(response);
            this._writeUsageLog();
            return this._createResponse(this.STATUS.SUCCESS, result);
        } catch (e) {
            this.LOG_MESSAGE = `[DocuGenLLM.generateDocumentation] Error: ${e}`;
            this._writeUsageLog();
            return this._createResponse(this.STATUS.BAD_REQUEST, `[DocuGenLLM.generateDocumentation]: ${e}`);
        }
    },

    generateTableDocumentation: function(recordSysId, recordDisplayValue, tableName) {
        this.REQUEST_TYPE = 'table documentation';
        let responseArr = [];

        try {
            const prompt = this._buildTableDocumentationPrompt(recordSysId, tableName);
            const jsonFormattedPrompt = this._formatRequest(prompt);

            if (this.DEBUG) responseArr.push(jsonFormattedPrompt);

            const response = this._callLLMAPI(jsonFormattedPrompt);
            if (this.DEBUG) responseArr.push(response);

            const documentation = this._parseLLMDocumentResponse(response);
            if (this.DEBUG) responseArr.push(documentation);

            const result = this._storeDocumentation(documentation, recordSysId, tableName, `Table: ${recordDisplayValue}`);
            if (this.DEBUG) responseArr.push(result);

            if (this.DEBUG) return this._createResponse(this.STATUS.DEBUG, responseArr);

            this.LOG_MESSAGE = JSON.stringify(response);
            this._writeUsageLog();
            return this._createResponse(this.STATUS.SUCCESS, result);
        } catch (e) {
            this.LOG_MESSAGE = `[DocuGenLLM.generateTableDocumentation] Error: ${e}`;
            this._writeUsageLog();
            return this._createResponse(this.STATUS.BAD_REQUEST, `[DocuGenLLM.generateTableDocumentation]: ${e}`);
        }
    },

    // New method for predictive maintenance suggestions
    generateMaintenanceSuggestions: function(recordSysId, tableName, recordDisplayValue) {
        this.REQUEST_TYPE = 'maintenance_suggestions';
        let responseArr = [];

        try {
            // Fetch script and change history
            const scriptData = this._getScriptData(recordSysId, tableName);
            const changeData = this._getScriptChangeHistory(recordSysId, tableName);

            // Check if documentation exists
            let existingDoc = this._getExistingDocumentation(recordSysId);

            // Build prompt for maintenance suggestions
            const prompt = this._buildMaintenancePrompt(scriptData, changeData, existingDoc);
            const jsonFormattedPrompt = this._formatRequest(prompt);

            if (this.DEBUG) responseArr.push(jsonFormattedPrompt);

            // Call LLM API
            const response = this._callLLMAPI(jsonFormattedPrompt);
            if (this.DEBUG) responseArr.push(response);

            const suggestions = this._parseLLMDocumentResponse(response);
            if (this.DEBUG) responseArr.push(suggestions);

            // Store suggestions
			if(!existingDoc) existingDoc = this._storeDocumentation(null, recordSysId, tableName, recordDisplayValue);

			const result = this._storeSuggestions(suggestions, recordSysId, tableName, recordDisplayValue, existingDoc.sys_id);
            if (this.DEBUG) responseArr.push(result);

            if (this.DEBUG) return this._createResponse(this.STATUS.DEBUG, responseArr);

            this.LOG_MESSAGE = JSON.stringify(response);
            this._writeUsageLog();
            return this._createResponse(this.STATUS.SUCCESS, result);
        } catch (e) {
            this.LOG_MESSAGE = `[DocuGenLLM.generateMaintenanceSuggestions] Error: ${e}`;
            this._writeUsageLog();
            return this._createResponse(this.STATUS.BAD_REQUEST, `[DocuGenLLM.generateMaintenanceSuggestions]: ${e}`);
        }
    },

	generateCodeReviewAnnotations: function(recordSysId, tableName, recordDisplayValue) {
        this.REQUEST_TYPE = 'code_review';
        let responseArr = [];

        try {
            const scriptData = this._getScriptData(recordSysId, tableName);
            const analysis = this._analyzeScript(scriptData.current.script || '', tableName);
            const prompt = this._buildCodeReviewPrompt(scriptData, analysis);
            const jsonFormattedPrompt = this._formatRequest(prompt);
			let existingDoc = this._getExistingDocumentation(recordSysId);

            if (this.DEBUG) responseArr.push(jsonFormattedPrompt);

            const response = this._callLLMAPI(jsonFormattedPrompt);
            if (this.DEBUG) responseArr.push(response);

            const annotations = this._parseLLMDocumentResponse(response);
            if (this.DEBUG) responseArr.push(annotations);
			
			if(!existingDoc.sys_id) existingDoc = this._storeDocumentation(null, recordSysId, tableName, recordDisplayValue);
			
            const result = this._storeCodeReviewAnnotations(annotations, recordSysId, tableName, recordDisplayValue, existingDoc.sys_id);
            if (this.DEBUG) responseArr.push(result);

            if (this.DEBUG) return this._createResponse(this.STATUS.DEBUG, responseArr);

            this.LOG_MESSAGE = JSON.stringify(response);
            this._writeUsageLog();
            return this._createResponse(this.STATUS.SUCCESS, result);
        } catch (e) {
            this.LOG_MESSAGE = `[DocuGenLLM.generateCodeReviewAnnotations] Error: ${e}`;
            this._writeUsageLog();
            return this._createResponse(this.STATUS.BAD_REQUEST, `[DocuGenLLM.generateCodeReviewAnnotations]: ${e}`);
        }
    },

    _createResponse: function(status, message) {
        return { status, message };
    },

    _getTableJsonObj: function(table) {
        try {
            var res = {
                table: {},
                columns: []
            };

            var tableGr = new GlideRecord('sys_db_object');
            tableGr.get(table);

            for (key in tableGr) {
                if (key !== 'sys_meta') res.table[key] = tableGr[key].getDisplayValue();
            }

            var columnGr = new GlideRecord('sys_dictionary');
            columnGr.addQuery('name', tableGr.name);
            columnGr.query();

            while (columnGr.next()) {
                var obj = {};
                obj.name = columnGr.element.toString();
                obj.label = columnGr.column_label.toString();
                obj.type = columnGr.type.getDisplayValue();
                obj.reference = columnGr.reference.getDisplayValue();
                obj.max_length = columnGr.max_length.getDisplayValue();
                obj.default_value = columnGr.default_value.toString();
                obj.display_column = columnGr.display.toString();

                res.columns.push(obj);
            }

            return res;
        } catch (e) {
            gs.error(`[DocuGenLLM._getTableJsonObj] Error: ${e}`);
            throw new Error(`[DocuGenLLM._getTableJsonObj] Error: ${e}`);
        }
    },

    _buildDocumentationPrompt: function(recordSysId, tableName) {
        try {
            let scriptAttributesObj = {};
            const recordGr = new GlideRecord(tableName);
            recordGr.get(recordSysId);

            for (key in recordGr) {
                if (!key.includes('sys_')) scriptAttributesObj[key] = recordGr[key].toString() || null;
            }

            const analysis = this._analyzeScript(scriptAttributesObj.script || '', tableName);
			const feedback = this._getFeedbackForRecord(recordSysId, tableName);

            const prompt = `Generate detailed documentation in markdown for the following ServiceNow ${recordGr.getTableName()} script. Include:
- **Purpose**: Describe the script's purpose and functionality.
- **Parameters**: List any parameters or inputs.
- **Logic Flow**: Explain the script's logic step-by-step.
- **Key Functionality**: Highlight critical features.
- **Dependencies**: List identified dependencies (e.g., Script Includes, APIs).
- **Integration Points**: Describe interactions with tables or platform APIs.
- **Potential Edge Cases**: Note potential issues like null checks or error handling.

Incorporate the following user feedback to improve output quality (e.g., address low ratings or specific comments):
\`\`\`json
${JSON.stringify(feedback)}
\`\`\`

Script Details:
\`\`\`json
${JSON.stringify(scriptAttributesObj)}
\`\`\`

Analysis Results:
\`\`\`json
${JSON.stringify(analysis)}
\`\`\`
`;

            return prompt;
        } catch (e) {
            gs.error(`[DocuGenLLM._buildDocumentationPrompt] Error: ${e}`);
            throw new Error(`[DocuGenLLM._buildDocumentationPrompt] Error: ${e}`);
        }
    },

    _buildTableDocumentationPrompt: function(recordSysId, tableName) {
        try {
            const tableUtil = new DocuGenTableSchemaUtil();
            const tableJson = tableUtil.getTableSchema(recordSysId);
			const analysis = this._analyzeTableUsage(tableName);
			const feedback = this._getFeedbackForRecord(recordSysId, tableName);

            return `You are an expert database designer that excels at data schema documentation. Generate detailed documentation in markdown for the ServiceNow table, ${tableName}. Include:
- **Purpose**: Describe the table's purpose and role in the system.
- **Parameters**: List key fields or configurations (e.g., reference fields, mandatory fields).
- **Table Structure**: Provide a detailed outline of the table's columns in a markdown table, noting name, label, type, reference (if applicable), max length, default value, and display column status. Use "null" for null values.
- **Key Functionality**: Highlight critical features or uses of the table.
- **Dependencies**: List dependencies (e.g., referenced tables, APIs).
- **Integration Points**: Describe interactions with other tables or platform APIs.
- **Potential Edge Cases**: Note potential issues (e.g., data validation, reference integrity).

Incorporate the following user feedback to improve output quality (e.g., address low ratings or specific comments):
\`\`\`json
${JSON.stringify(feedback)}
\`\`\`

Table Schema:
\`\`\`json
${JSON.stringify(tableJson)}
\`\`\`

Analysis Results:
\`\`\`json
${JSON.stringify(analysis)}
\`\`\`
`;
        } catch (e) {
            gs.error(`[DocuGenLLM._buildTableDocumentationPrompt] Error: ${e}`);
            throw new Error(`[DocuGenLLM._buildTableDocumentationPrompt] Error: ${e}`);
        }
    },

    _buildAnnotationPrompt: function(recordSysId, tableName) {
        try {
            let scriptAttributesObj = {};
            const recordGr = new GlideRecord(tableName);
            recordGr.get(recordSysId);

            for (key in recordGr) {
                if (/(^|\W)script($|\W)/i.test(key) || key === 'condition') scriptAttributesObj[key] = recordGr[key].toString();
            }

			const feedback = this._getFeedbackForRecord(recordSysId, tableName);

            return `As an expert JavaScript developer, generate JSDOC annotation for the following code in the JSON object. Only respond with the annotated code. Provide helpful commentary for future developers to understand how the code works, incorporating the following user feedback to improve output quality (e.g., address low ratings or specific comments):
\`\`\`json
${JSON.stringify(feedback)}
\`\`\`

If there are multiple scripts, separate the scripts into code blocks with |||. Do not make them into variables in the same script, and do not add any code elements. Only comment on the code that is there. Do not provide any commentary or headers regarding the annotation.\n\n\`\`\`json\n${JSON.stringify(scriptAttributesObj)}\n\`\`\``;
        } catch (e) {
            gs.error(`[DocuGenLLM._buildAnnotationPrompt] Error: ${e}`);
            throw new Error(`[DocuGenLLM._buildAnnotationPrompt] Error: ${e}`);
        }
    },

    _buildMaintenancePrompt: function(scriptData, changeData, existingDoc) {
        try {
			const feedback = this._getFeedbackForRecord(scriptData.current.sys_id, scriptData.current.tableName);

            return `Analyze the following ServiceNow script changes and existing documentation to suggest updates to keep the documentation current. Provide suggestions in markdown format, including:
- **Suggested Documentation Updates**: Changes to the existing documentation to reflect script modifications.
- **Suggested Annotation Updates**: Updates to JSDOC or inline comments to align with code changes.
- **Rationale**: Explain why each suggestion is needed based on the changes.

If there is no existing documentation or no script available, along with your own documentation or annotation suggestions, suggest running DocuGenLLM Code Documentation to generate new documentation, or DocuGenLLM Code Annotation for code annotation via available UI actions.

Incorporate the following user feedback to improve output quality (e.g., address low ratings or specific comments):
\`\`\`json
${JSON.stringify(feedback)}
\`\`\`

Current Script:
\`\`\`json
${JSON.stringify(scriptData.current)}
\`\`\`

Previous Script (if available):
\`\`\`json
${JSON.stringify(scriptData.previous || {})}
\`\`\`

Change History:
\`\`\`json
${JSON.stringify(changeData)}
\`\`\`

Existing Documentation:
\`\`\`markdown
${existingDoc.documentation || 'No existing documentation'}
\`\`\`

Existing Annotations:
\`\`\`markdown
${existingDoc.annotations || 'No existing annotations'}
\`\`\`
`;
        } catch (e) {
            gs.error(`[DocuGenLLM._buildMaintenancePrompt] Error: ${e}`);
            throw new Error(`[DocuGenLLM._buildMaintenancePrompt] Error: ${e}`);
        }
    },

	_buildCodeReviewPrompt: function(scriptData, analysis) {
        try {
            // Summarize large scripts to reduce token count
            var scriptContent = scriptData.current.script || '';
            var scriptSummary = scriptContent;
            if (scriptContent.split('\n').length > 100) { // Summarize if > 100 lines
                var lines = scriptContent.split('\n');
                scriptSummary = [
                    lines[0], // First line (e.g., function declaration)
                    '// [Script truncated for brevity; full script available in source]',
                    ...lines.slice(1).filter(line => line.match(/function\s+\w+\s*\(/) || line.match(/GlideRecord\s*\(/) || line.match(/gs\./)).slice(0, 10), // Key lines
                    '// [End of summary]'
                ].join('\n');
            }

			const feedback = this._getFeedbackForRecord(scriptData.current.sys_id, scriptData.current.tableName);

            return `As an expert ServiceNow developer, perform a code review for the following script. Generate detailed annotations in markdown, including:
- **Identified Issues**: Highlight potential issues (e.g., deprecated APIs, performance bottlenecks).
- **Best Practice Suggestions**: Recommend ServiceNow coding best practices (e.g., error handling, logging, ACL checks).
- **Remediation Steps**: Suggest specific changes to address each issue or implement best practices.
- **Code Context**: Provide inline comments in the script to mark issues or suggestions, using // for single-line comments.

Incorporate the following user feedback to improve output quality (e.g., address low ratings or specific comments):
\`\`\`json
${JSON.stringify(feedback)}
\`\`\`

Script Details (summarized if large):
\`\`\`javascript
${scriptSummary}
\`\`\`

Analysis Results:
\`\`\`json
${JSON.stringify(analysis)}
\`\`\`
`;
        } catch (e) {
            gs.error(`[DocuGenLLM._buildCodeReviewPrompt] Error: ${e}`);
            throw new Error(`[DocuGenLLM._buildCodeReviewPrompt] Error: ${e}`);
        }
    },

    _formatRequest: function(prompt) {
        try {
            let promptJson;
            let obj = JSON.parse(this.APIPROMPT);
            this._setNestedValue(obj, this.PROMPTATTRIBUTE, prompt);
            promptJson = obj;

            return obj;
        } catch (e) {
            gs.error(`[DocuGenLLMClientUtils._formatPrompt] Error: ${e}`);
            throw new Error(`[DocuGenLLMClientUtils._formatPrompt] Error: ${e}`);
        }
    },

    _callLLMAPI: function(prompt) {
        try {
            const restMessage = new sn_ws.RESTMessageV2();
            restMessage.setEndpoint(this.LLMENDPOINT);
            restMessage.setHttpMethod('POST');
            restMessage.setRequestHeader('Authorization', `Bearer ${this.APIKEY}`);
            restMessage.setRequestHeader('Content-Type', 'application/json');
            restMessage.setRequestBody(JSON.stringify(prompt));
			restMessage.setHttpTimeout(120000);
			
            const response = restMessage.execute();
            if (response.getStatusCode() != 200) {
                this.LOG_LEVEL = 2;
                throw new Error(`[DocuGenLLMClientUtils._callLLMAPI] Error: LLM API call failed: ${response.getErrorMessage()}`);
            }

            this.LOG_LEVEL = 0;
            return response.getBody();
        } catch (e) {
            gs.error(`[DocuGenLLMClientUtils._callLLMAPI] Error: ${e}`);
            throw new Error(`[DocuGenLLMClientUtils._callLLMAPI] Error: ${e}`);
        }
    },

    _parseLLMDocumentResponse: function(response) {
        let result;
        try {
            switch (this.MODEL) {
                case 'chatgpt':
                case 'grok':
                    result = JSON.parse(response).choices[0].message.content;
                    break;
                case 'claude':
                    result = JSON.parse(response).content.text;
                    break;
                default:
                    result = 'No documentation generated';
            }
            return result;
        } catch (e) {
            gs.error(`[DocuGenLLM._parseLLMDocumentResponse] Error: ${e}`);
            gs.error(`[DocuGenLLM._parseLLMDocumentResponse] responseObj: ${response}`);
            throw new Error(`[DocuGenLLM._parseLLMDocumentResponse] Error: ${e}`);
        }
    },

    _parseLLMAnnotationResponse: function(response) {
        let tempResult;
        try {
            switch (this.MODEL) {
                case 'chatgpt':
                case 'grok':
                    tempResult = JSON.parse(response).choices[0].message.content;
                    break;
                case 'claude':
                    tempResult = JSON.parse(response).content.text;
                    break;
                default:
                    tempResult = 'No documentation generated';
            }

            let resultArr = tempResult.split('|||');
            resultArr.forEach((result, index) => {
                resultArr[index] = result.replace('```javascript', '').replace('```', '');
            });

            return resultArr.join('\n\n');
        } catch (e) {
            gs.error(`[DocuGenLLM._parseLLMAnnotationResponse] Error: ${e}`);
            gs.error(`[DocuGenLLM._parseLLMAnnotationResponse] responseObj: ${response}`);
            throw new Error(`[DocuGenLLM._parseLLMAnnotationResponse] Error: ${e}`);
        }
    },

    _storeDocumentation: function(documentation, recordSysId, tableName, displayValue) {
        try {
            let sys_id;
			const docGr = new GlideRecord(this.DOCS_TABLE);
            docGr.addQuery('u_script_reference', recordSysId);
            docGr.query();

            if (docGr.next()) {
                docGr.u_name = displayValue;
                docGr.u_documentation_markdown = documentation;
                docGr.u_documentation_generated_by = this.MODEL_SYS_ID;
                sys_id = docGr.update();
            } else {
                docGr.initialize();
                docGr.u_name = displayValue;
                docGr.u_script_reference = recordSysId;
                docGr.u_script_type = tableName;
                docGr.u_documentation_markdown = documentation;
                docGr.u_documentation_generated_by = this.MODEL_SYS_ID;
                sys_id = docGr.insert();
            }

            return {
				sys_id: sys_id,
                title: docGr.getDisplayValue(),
                link: `${gs.getProperty('glide.servlet.uri')}${docGr.getLink()}`
            };
        } catch (e) {
            gs.error(`[DocuGenLLM._storeDocumentation] Error: ${e}`);
            throw new Error(`[DocuGenLLM._storeDocumentation] Error: ${e}`);
        }
    },

    _storeAnnotation: function(annotation, recordSysId, tableName, displayValue) {
        try {
			let sys_id;
            const docGr = new GlideRecord(this.DOCS_TABLE);
            docGr.addQuery('u_script_reference', recordSysId);
            docGr.query();

            if (docGr.next()) {
                docGr.u_name = displayValue;
                docGr.u_script = annotation;
                docGr.u_script_generated_by = this.MODEL_SYS_ID;
                sys_id = docGr.update();
            } else {
                docGr.initialize();
                docGr.u_name = displayValue;
                docGr.u_script_reference = recordSysId;
                docGr.u_script_type = tableName;
                docGr.u_script = annotation;
                docGr.u_script_generated_by = this.MODEL_SYS_ID;
                sys_id = docGr.insert();
            }

            return {
				sys_id: sys_id,
                title: docGr.getDisplayValue(),
                link: `${gs.getProperty('glide.servlet.uri')}${docGr.getLink()}`
            };
        } catch (e) {
            gs.error(`[DocuGenLLM._storeAnnotation] Error: ${e}`);
            throw new Error(`[DocuGenLLM._storeAnnotation] Error: ${e}`);
        }
    },

	_storeCodeReviewAnnotations: function(annotations, recordSysId, tableName, displayValue, existingDoc) {
        try {
            var sugGr = new GlideRecord(this.SUGGESTIONS_TABLE);
            sugGr.addQuery('u_script_reference', recordSysId);
            sugGr.query();

            if (sugGr.next()) {
                sugGr.u_name = displayValue;
                sugGr.u_code_review = annotations;
				sugGr.u_document_reference = existingDoc;
                sugGr.u_generated_by = this.MODEL_SYS_ID;
                sugGr.update();
            } else {
                sugGr.initialize();
                sugGr.u_name = displayValue;
                sugGr.u_script_reference = recordSysId;
                sugGr.u_script_type = tableName;
                sugGr.u_code_review = annotations;
				sugGr.u_document_reference = existingDoc;
                sugGr.u_generated_by = this.MODEL_SYS_ID;
                sugGr.insert();
            }

            return {
                'title': sugGr.getDisplayValue(),
                'link': `${gs.getProperty('glide.servlet.uri')}${sugGr.getLink()}`
            };
        } catch (e) {
            gs.error(`[DocuGenLLM._storeCodeReviewAnnotations] Error: ${e}`);
            throw new Error(`[DocuGenLLM._storeCodeReviewAnnotations] Error: ${e}`);
        }
    },

    _storeSuggestions: function(suggestions, recordSysId, tableName, displayValue, existingDoc) {
        try {
            var sugGr = new GlideRecord(this.SUGGESTIONS_TABLE);
            sugGr.addQuery('u_script_reference', recordSysId);
            sugGr.query();

            if(sugGr.next()) {
                sugGr.u_name = displayValue;
                sugGr.u_suggestions_markdown = suggestions;
				sugGr.u_document_reference = existingDoc;
                sugGr.u_generated_by = this.MODEL_SYS_ID;
                sugGr.update();
            } else {
                sugGr.initialize();
                sugGr.u_script_reference = recordSysId;
                sugGr.u_script_type = tableName;
                sugGr.u_name = displayValue;
                sugGr.u_suggestions_markdown = suggestions;
                sugGr.u_document_reference = existingDoc;
                sugGr.u_generated_by = this.MODEL_SYS_ID;
                sugGr.insert();
            }

            return {
                'title': sugGr.getDisplayValue(),
                'link': `${gs.getProperty('glide.servlet.uri')}${sugGr.getLink()}`
            };
        } catch (e) {
            gs.error(`[DocuGenLLM._storeSuggestions] Error: ${e}`);
            throw new Error(`[DocuGenLLM._storeSuggestions] Error: ${e}`);
        }
    },

    _getScriptData: function(recordSysId, tableName) {
        try {
            var recordGr = new GlideRecord(tableName);
            if (!recordGr.get(recordSysId)) {
                throw new Error('Script record not found');
            }

            var scriptField = this._getScriptField(tableName);
            return {
                current: {
                    script: recordGr[scriptField] ? recordGr[scriptField].toString() : '',
                    name: recordGr.name ? recordGr.name.toString() : ''
                }
            };
        } catch (e) {
            gs.error(`[DocuGenLLM._getScriptData] Error: ${e}`);
            throw new Error(`[DocuGenLLM._getScriptData] Error: ${e}`);
        }
    },

    _getScriptChangeHistory: function(recordSysId, tableName) {
        try {
            var history = [];
            var historyGr = new GlideRecord('sys_history_line');
            historyGr.addQuery('set', 'CONTAINS', recordSysId);
            historyGr.addQuery('field', this._getScriptField(tableName));
            historyGr.orderByDesc('sys_created_on');
            historyGr.setLimit(1); // Get the most recent change
            historyGr.query();

            if (historyGr.next()) {
                history.push({
                    old_value: historyGr.old_value.toString(),
                    new_value: historyGr.new_value.toString(),
                    changed_by: historyGr.user_name.toString(),
                    changed_on: historyGr.sys_created_on.toString()
                });
            }

            return history;
        } catch (e) {
            gs.error(`[DocuGenLLM._getScriptChangeHistory] Error: ${e}`);
            throw new Error(`[DocuGenLLM._getScriptChangeHistory] Error: ${e}`);
        }
    },

    _getExistingDocumentation: function(recordSysId) {
        try {
            var docGr = new GlideRecord(this.DOCS_TABLE);
            docGr.addQuery('u_script_reference', recordSysId);
            docGr.query();

            if (docGr.next()) {
                return {
                    sys_id: docGr.getUniqueValue(),
                    documentation: docGr.u_documentation_markdown.toString() || '',
                    annotations: docGr.u_script.toString() || ''
                };
            }
            return { documentation: '', annotations: '' };
        } catch (e) {
            gs.error(`[DocuGenLLM._getExistingDocumentation] Error: ${e}`);
            throw new Error(`[DocuGenLLM._getExistingDocumentation] Error: ${e}`);
        }
    },

	_getFeedbackForRecord: function(recordSysId, tableName) {
        try {
            var feedback = [];
            var feedbackGr = new GlideRecord(this.FEEDBACK_TABLE);
            if (tableName === 'u_docugen_code_docs') {
                feedbackGr.addQuery('u_document_reference', recordSysId);
            } else if (tableName === 'u_docugen_suggestions') {
                feedbackGr.addQuery('u_suggestion_reference', recordSysId);
            } else {
                feedbackGr.addQuery('u_script_reference', recordSysId);
            }
			feedbackGr.addEncodedQuery('u_status=1^u_commentsISNOTEMPTY');
            feedbackGr.orderByDesc('u_timestamp');
            feedbackGr.setLimit(5); // Limit to recent feedback
            feedbackGr.query();

            while (feedbackGr.next()) {
                feedback.push({
                    rating: feedbackGr.u_rating.toString(),
                    comments: feedbackGr.u_comments.toString(),
                    timestamp: feedbackGr.u_timestamp.toString()
                });
            }

            return feedback;
        } catch (e) {
            gs.error(`[DocuGenLLM._getFeedbackForRecord] Error: ${e}`);
            return [];
        }
    },

    _getScriptField: function(tableName) {
        var fieldMap = {
            'sys_script': 'script',
            'sys_script_client': 'script',
            'sys_script_include': 'script'
        };
        return fieldMap[tableName] || 'script';
    },

    _writeUsageLog: function() {
        try {
            const logGr = new GlideRecord('u_docugenllm_usage_log');
            logGr.source = this.LOG_SOURCE;
            logGr.level = this.LOG_LEVEL;
            logGr.u_model = this.MODEL;
            logGr.u_request_type = this.REQUEST_TYPE;
            logGr.message = this.LOG_MESSAGE;
            logGr.insert();
        } catch (e) {
            gs.error(`[DocuGenLLM._writeUsageLog] Error: ${e}`);
            throw new Error(`[DocuGenLLM._writeUsageLog] Error: ${e}`);
        }
    },

    _setNestedValue: function(obj, keyStr, newValue) {
        const parts = keyStr.split('.');
        let target = obj;
        let lastPart = parts.pop();

        for (let part of parts) {
            if (part.includes('[')) {
                const match = part.match(/(\w+)\[(\d+)\]/);
                if (match) {
                    const base = match[1];
                    const idx = parseInt(match[2], 10);
                    target = target[base][idx];
                } else {
                    target = target[part];
                }
            } else {
                target = target[part];
            }
        }

        if (lastPart.includes('[')) {
            const match = lastPart.match(/(\w+)\[(\d+)\]/);
            if (match) {
                const base = match[1];
                const idx = parseInt(match[2], 10);
                target[base][idx] = newValue;
            } else {
                target[lastPart] = newValue;
            }
        } else {
            target[lastPart] = newValue;
        }
    },

    _analyzeScript: function(scriptContent, tableName) {
        var analysis = {
            dependencies: [],
            integrations: [],
            edgeCases: []
        };

        var scriptIncludePattern = /new\s+([A-Za-z0-9_]+)\s*\(\)/g;
        var matches = scriptContent.match(scriptIncludePattern);
        if (matches) {
            matches.forEach(function(match) {
                var scriptIncludeName = match.replace(/new\s+|\s*\(\)/g, '');
                var sysId = this._getScriptIncludeSysId(scriptIncludeName);
                analysis.dependencies.push({
                    type: 'Script Include',
                    name: scriptIncludeName,
                    sysId: sysId || null
                });
            }, this);
        }

        var restPattern = /(GlideHTTPClient|sn_ws\.RESTMessageV2)/g;
        if (scriptContent.match(restPattern)) {
            analysis.dependencies.push({
                type: 'REST API',
                name: 'External Service Call'
            });
        }

        var glideRecordPattern = /GlideRecord\s*\(\s*['"]([a-zA-Z0-9_]+)['"]\s*\)/g;
        matches = scriptContent.match(glideRecordPattern);
        if (matches) {
            matches.forEach(function(match) {
                var tableName = match.replace(/GlideRecord\s*\(\s*['"]|['"]\s*\)/g, '');
                analysis.integrations.push({
                    type: 'Table',
                    name: tableName
                });
            });
        }

        var gsPattern = /gs\.(info|error|log|eventQueue)\s*\(/g;
        if (scriptContent.match(gsPattern)) {
            analysis.integrations.push({
                type: 'ServiceNow Platform',
                name: 'Platform Logging/Eventing'
            });
        }

        var varAccessPattern = /\b(\w+)\.\w+/g;
        var nullCheckPattern = /if\s*\(\s*!?\s*\w+\s*(===|==)\s*null\s*\)/g;
        var variables = scriptContent.match(varAccessPattern) || [];
        var hasNullChecks = scriptContent.match(nullCheckPattern);

        if (variables.length > 0 && !hasNullChecks) {
            analysis.edgeCases.push('Potential missing null check for object property access');
        }

        if (!scriptContent.match(/try\s*{/)) {
            analysis.edgeCases.push('No try-catch block for error handling');
        }

        var hardcodedPattern = /['"]([a-zA-Z0-9_-]+)['"]/g;
        var hardcodedValues = scriptContent.match(hardcodedPattern);
        if (hardcodedValues && hardcodedValues.length > 5) {
            analysis.edgeCases.push('Multiple hardcoded values detected; consider using configuration');
        }

        return analysis;
    },

	_analyzeTableUsage: function(tableName) {
        try {
            var analysis = {
                dependencies: [],
                integrations: [],
                edgeCases: []
            };

            // Check for referenced tables in sys_dictionary
            var dictGr = new GlideRecord('sys_dictionary');
            dictGr.addQuery('name', tableName);
            dictGr.addQuery('reference', '!=', '');
            dictGr.query();
            while (dictGr.next()) {
                analysis.dependencies.push({
                    type: 'Referenced Table',
                    name: dictGr.reference.getDisplayValue()
                });
            }

            // Check for scripts referencing this table
            var scriptTables = ['sys_script', 'sys_script_client', 'sys_script_include'];
            scriptTables.forEach(function(scriptTable) {
                var scriptGr = new GlideRecord(scriptTable);
                scriptGr.addQuery('script', 'CONTAINS', 'GlideRecord(\'' + tableName + '\'');
                scriptGr.query();
                while (scriptGr.next()) {
                    analysis.integrations.push({
                        type: 'Script Reference',
                        name: scriptGr.name + ' (' + scriptTable + ')'
                    });
                }
            });

            // Edge cases for table
            if (dictGr.getRowCount() === 0) {
                analysis.edgeCases.push('No reference fields defined; verify if table is isolated or underutilized.');
            }
            var mandatoryGr = new GlideRecord('sys_dictionary');
            mandatoryGr.addQuery('name', tableName);
            mandatoryGr.addQuery('mandatory', true);
            mandatoryGr.query();
            if (!mandatoryGr.hasNext()) {
                analysis.edgeCases.push('No mandatory fields defined; consider adding to ensure data integrity.');
            }

            return analysis;
        } catch (e) {
            gs.error(`[DocuGenLLM._analyzeTableUsage] Error: ${e}`);
            throw new Error(`[DocuGenLLM._analyzeTableUsage] Error: ${e}`);
        }
    },

    _getScriptIncludeSysId: function(name) {
        var gr = new GlideRecord('sys_script_include');
        gr.addQuery('name', name);
        gr.query();
        if (gr.next()) {
            return gr.sys_id.toString();
        }
        return null;
    },

    _simulateAPIDocumentationResponse: function(model) {
        let response;

        switch (model) {
            case "chatgpt":
                response = JSON.stringify([
                    {
                        "id": "msg_67b73f697ba4819183a15cc17d011509",
                        "type": "message",
                        "role": "assistant",
                        "content": [
                            {
                                "type": "output_text",
                                "text": "Under the soft glow of the moon, Luna the unicorn danced through fields of twinkling stardust, leaving trails of dreams for every child asleep.",
                                "annotations": []
                            }
                        ]
                    }
                ]);
                break;
            case "grok":
                response = JSON.stringify({
                    "id": "6dd0e908-dd7c-6ea7-67cb-31d841a5d3f2_us-east-1",
                    "object": "chat.completion",
                    "created": 1757715272,
                    "model": "grok-4-0709",
                    "choices": [{
                        "index": 0,
                        "message": {
                            "role": "assistant",
                            "content": "# Maintenance Suggestions for Client Script: Form Control - Validate JSON\n\n## Suggested Documentation Updates\n- Update **Logic Flow** section to include new validation for empty strings.\n- Add new dependency on `UtilsValidator` Script Include in **Dependencies** section.\n\n## Suggested Annotation Updates\n```javascript\n/** Validates JSON input and checks for empty strings */\nfunction onSubmit() {\n    var prompt = g_form.getValue('u_prompt');\n    if (!prompt) return false; // Added check for empty input\n    try {\n        JSON.parse(prompt);\n        return true;\n    } catch (e) {\n        g_form.showFieldMsg('u_prompt', 'Invalid JSON', 'error');\n        return false;\n    }\n}\n```\n\n## Rationale\n- **Empty String Check**: The script now checks for empty inputs, which requires updating the documentation to reflect this new validation step.\n- **New Dependency**: The script references `UtilsValidator`, which should be documented to ensure traceability.",
                            "refusal": null
                        },
                        "finish_reason": "stop"
                    }],
                    "usage": {
                        "prompt_tokens": 897,
                        "completion_tokens": 703,
                        "total_tokens": 1949,
                        "prompt_tokens_details": {
                            "text_tokens": 897,
                            "audio_tokens": 0,
                            "image_tokens": 0,
                            "cached_tokens": 896
                        },
                        "completion_tokens_details": {
                            "reasoning_tokens": 349,
                            "audio_tokens": 0,
                            "accepted_prediction_tokens": 0,
                            "rejected_prediction_tokens": 0
                        },
                        "num_sources_used": 0
                    },
                    "system_fingerprint": "fp_19e21a36c0"
                });
                break;
            case 'claude':
                response = JSON.stringify({
                    "id": "msg_01HCDu5LRGeP2o7s2xGmxyx8",
                    "type": "message",
                    "role": "assistant",
                    "content": [
                        {
                            "type": "text",
                            "text": "# Maintenance Suggestions\n\n## Suggested Documentation Updates\n- Add empty string validation to Logic Flow.\n\n## Suggested Annotation Updates\n```javascript\n/** Validates JSON and empty inputs */\nfunction onSubmit() {\n    var prompt = g_form.getValue('u_prompt');\n    if (!prompt) return false;\n    try {\n        JSON.parse(prompt);\n        return true;\n    } catch (e) {\n        g_form.showFieldMsg('u_prompt', 'Invalid JSON', 'error');\n        return false;\n    }\n}\n```\n\n## Rationale\n- The script now prevents empty submissions, which needs documentation."
                        }
                    ],
                    "model": "claude-sonnet-4-20250514",
                    "usage": {
                        "input_tokens": 21,
                        "output_tokens": 305
                    }
                });
                break;
        }

        return response;
    },

    type: 'DocuGenLLMClientUtils'
});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-12 13:54:08</sys_created_on>
        <sys_id>b5441bbb83f7621046cfe4d0deaad3a4</sys_id>
        <sys_mod_count>273</sys_mod_count>
        <sys_name>DocuGenLLMClientUtils</sys_name>
        <sys_package display_value="DocuGenLLM" source="54a6cf7783b7621046cfe4d0deaad30f">54a6cf7783b7621046cfe4d0deaad30f</sys_package>
        <sys_policy/>
        <sys_scope display_value="DocuGenLLM">54a6cf7783b7621046cfe4d0deaad30f</sys_scope>
        <sys_update_name>sys_script_include_b5441bbb83f7621046cfe4d0deaad3a4</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-10-20 16:09:19</sys_updated_on>
    </sys_script_include>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>b5441bbb83f7621046cfe4d0deaad3a4</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-12 13:54:07</sys_created_on>
        <sys_id>6c359bfb83f7621046cfe4d0deaad3ec</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-12 13:54:07</sys_updated_on>
        <table>sys_script_include</table>
        <use_es_latest>true</use_es_latest>
    </sys_es_latest_script>
</record_update>
