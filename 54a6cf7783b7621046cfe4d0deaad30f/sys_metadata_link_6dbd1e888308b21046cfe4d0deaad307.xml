<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>/</directory>
        <documentkey>documentation_demo_record</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
&lt;unload unload_date="2025-09-13 04:29:49"&gt;&#13;
&lt;u_docugen_code_docs action="INSERT_OR_UPDATE"&gt;&#13;
&lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;&#13;
&lt;sys_created_on&gt;2025-09-12 23:13:55&lt;/sys_created_on&gt;&#13;
&lt;sys_id&gt;e05551c08380b21046cfe4d0deaad3fd&lt;/sys_id&gt;&#13;
&lt;sys_mod_count&gt;0&lt;/sys_mod_count&gt;&#13;
&lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;&#13;
&lt;sys_updated_on&gt;2025-09-12 23:13:55&lt;/sys_updated_on&gt;&#13;
&lt;u_documentation&gt;&lt;![CDATA[&lt;div class="markdown-body"&gt;&#13;
			&lt;style&gt;.markdown-body {&#13;
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;&#13;
  line-height:1.6;&#13;
  max-width:900px;&#13;
  margin:0 auto;&#13;
  padding:20px;&#13;
  color:#333;&#13;
}&#13;
&#13;
.markdown-body h1 {&#13;
  font-size:2.2em;&#13;
  border-bottom:2px solid #eaecef;&#13;
  padding-bottom:0.3em;&#13;
  margin-top:1.5em;&#13;
  margin-bottom:0.5em;&#13;
}&#13;
&#13;
.markdown-body h2 {&#13;
  font-size:1.8em;&#13;
  border-bottom:1px solid #eaecef;&#13;
  padding-bottom:0.3em;&#13;
  margin-top:1.2em;&#13;
  margin-bottom:0.5em;&#13;
}&#13;
&#13;
.markdown-body h3 {&#13;
  font-size:1.4em;&#13;
  margin-top:1em;&#13;
  margin-bottom:0.5em;&#13;
}&#13;
&#13;
.markdown-body h4 {&#13;
  font-size:1.2em;&#13;
  margin-top:1em;&#13;
  margin-bottom:0.5em;&#13;
}&#13;
&#13;
.markdown-body p { margin:0.8em 0; }&#13;
&#13;
.markdown-body ul,&#13;
.markdown-body ol {&#13;
  padding-left:2em;&#13;
  margin:0.8em 0;&#13;
}&#13;
&#13;
.markdown-body li { margin:0.4em 0; }&#13;
&#13;
.markdown-body code {&#13;
  background:#f6f8fa;&#13;
  padding:0.2em 0.4em;&#13;
  border-radius:3px;&#13;
  font-family:'SFMono-Regular',Consolas,'Liberation Mono',Menlo,monospace;&#13;
  font-size:85%;&#13;
}&#13;
&#13;
.markdown-body pre {&#13;
  background:#f6f8fa;&#13;
  padding:1em;&#13;
  border-radius:6px;&#13;
  overflow-x:auto;&#13;
  margin:0.8em 0;&#13;
}&#13;
&#13;
.markdown-body pre code {&#13;
  background:none;&#13;
  padding:0;&#13;
}&#13;
&#13;
.markdown-body blockquote {&#13;
  border-left:4px solid #dfe2e5;&#13;
  padding:0 1em;&#13;
  color:#6a737d;&#13;
  margin:0.8em 0;&#13;
}&#13;
&#13;
.markdown-body a {&#13;
  color:#0366d6;&#13;
  text-decoration:none;&#13;
}&#13;
&#13;
.markdown-body a:hover { text-decoration:underline; }&#13;
&lt;/style&gt;&#13;
		&lt;h1&gt;Documentation for Script Include: DocuGenLLMClientUtils&lt;/h1&gt;&#13;
&#13;
&lt;h2&gt;Overview&lt;/h2&gt;&#13;
&lt;p&gt;This is a ServiceNow Script Include that defines a client-callable AJAX processor for generating documentation using Large Language Models (LLMs). It is configured to be active, publicly accessible, and client-callable, but not mobile-callable or sandbox-callable. The class extends &lt;code&gt;global.AbstractAjaxProcessor&lt;/code&gt; to handle AJAX requests. It integrates with external LLM APIs to automatically generate markdown-formatted documentation for ServiceNow scripts based on their attributes.&lt;/p&gt;&#13;
&#13;
&lt;h2&gt;Purpose&lt;/h2&gt;&#13;
&lt;p&gt;The primary purpose of this Script Include is to automate the generation of detailed documentation for ServiceNow records (e.g., scripts) by leveraging LLMs. It fetches configuration from a models table, constructs a prompt with the record&amp;#39;s non-system fields, sends it to an LLM API, parses the response, and stores the resulting documentation in a dedicated table. This facilitates documentation generation for development and maintenance, with built-in error handling, debugging support, and model-specific parsing. It supports multiple LLM models (e.g., Grok, ChatGPT, Claude) and ensures data integrity by ignoring system fields.&lt;/p&gt;&#13;
&#13;
&lt;h2&gt;Parameters&lt;/h2&gt;&#13;
&lt;p&gt;The Script Include is structured as a class with an &lt;code&gt;initialize&lt;/code&gt; method and several public and private methods. Key parameters across methods include:&lt;/p&gt;&#13;
&#13;
&lt;ul&gt;&lt;li&gt;**initialize(model&amp;#61;null)**:&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;&amp;#96;model&amp;#96; (String, optional): The name of the LLM model to use from the &amp;#96;u_models&amp;#96; table. If not provided, it queries for the default model (where &amp;#96;u_default&amp;#96; is true).&lt;/li&gt;&lt;/ul&gt;&#13;
&lt;/li&gt;&lt;/ul&gt;&#13;
&#13;
&lt;ul&gt;&lt;li&gt;**generateDocumentation(recordSysId, recordDisplayValue, tableName, modelRecordName&amp;#61;null)**:&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;&amp;#96;recordSysId&amp;#96; (String): The sys_id of the record (e.g., script) to generate documentation for.&lt;/li&gt;&lt;li&gt;&amp;#96;recordDisplayValue&amp;#96; (String): The display value (e.g., name) of the record.&lt;/li&gt;&lt;li&gt;&amp;#96;tableName&amp;#96; (String): The table name of the record (e.g., &amp;#96;sys_script_include&amp;#96;).&lt;/li&gt;&lt;li&gt;&amp;#96;modelRecordName&amp;#96; (String, optional): An alternative model name to override the initialized one.&lt;/li&gt;&lt;/ul&gt;&#13;
&lt;/li&gt;&lt;/ul&gt;&#13;
&#13;
&lt;p&gt;Private methods have internal parameters derived from the public ones or class properties, such as prompts, API endpoints, and response objects. No explicit parameters are exposed for client-side calls beyond those in &lt;code&gt;generateDocumentation&lt;/code&gt;, as it is the main entry point.&lt;/p&gt;&#13;
&#13;
&lt;h2&gt;Logic Flow&lt;/h2&gt;&#13;
&lt;p&gt;The Script Include operates as an AJAX processor, with logic centered around the &lt;code&gt;generateDocumentation&lt;/code&gt; method. Below is a step-by-step breakdown of the overall flow:&lt;/p&gt;&#13;
&#13;
&lt;ol&gt;&lt;li&gt;**Initialization**:&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;Sets debug mode (&amp;#96;DEBUG &amp;#61; true&amp;#96;) and constants (e.g., &amp;#96;DOCS_TABLE &amp;#61; &amp;#39;u_docugen_code_docs&amp;#39;&amp;#96;).&lt;/li&gt;&lt;li&gt;Queries the &amp;#96;u_models&amp;#96; table for the specified or default model.&lt;/li&gt;&lt;li&gt;Loads model configuration (e.g., &amp;#96;LLMENDPOINT&amp;#96;, &amp;#96;APIKEY&amp;#96;, &amp;#96;APIPROMPT&amp;#96;, &amp;#96;MODEL&amp;#96;).&lt;/li&gt;&lt;li&gt;Defines status codes (e.g., &amp;#96;SUCCESS: 200&amp;#96;).&lt;/li&gt;&lt;li&gt;Throws an error if no model is found.&lt;/li&gt;&lt;/ul&gt;&#13;
&lt;/li&gt;&lt;/ol&gt;&#13;
&#13;
&lt;ol&gt;&lt;li&gt;**Generate Documentation (Main Method)**:&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;Checks for initialization errors.&lt;/li&gt;&lt;li&gt;Builds a prompt using &amp;#96;_buildPrompt&amp;#96;, which retrieves the record, extracts non-system fields into a JSON object, and formats a markdown prompt.&lt;/li&gt;&lt;li&gt;Formats the API request using &amp;#96;_formatRequest&amp;#96;, which parses &amp;#96;APIPROMPT&amp;#96; and sets the prompt into a nested structure via &amp;#96;_setNestedValue&amp;#96;.&lt;/li&gt;&lt;li&gt;Calls the LLM API using &amp;#96;_callLLMAPI&amp;#96; (or simulates in debug mode, though commented out).&lt;/li&gt;&lt;li&gt;Parses the response using &amp;#96;_parseLLMResponse&amp;#96;, handling model-specific formats (e.g., for &amp;#39;grok&amp;#39;, extracts &amp;#96;choices[0].message.content&amp;#96;).&lt;/li&gt;&lt;li&gt;Stores the documentation using &amp;#96;_storeDocumentation&amp;#96;, updating or inserting into &amp;#96;u_docugen_code_docs&amp;#96;.&lt;/li&gt;&lt;li&gt;Returns a response object with status and message (includes debug array if &amp;#96;DEBUG&amp;#96; is true).&lt;/li&gt;&lt;/ul&gt;&#13;
&lt;/li&gt;&lt;/ol&gt;&#13;
&#13;
&lt;ol&gt;&lt;li&gt;**API Call and Parsing**:&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;&amp;#96;_callLLMAPI&amp;#96;: Configures a REST message with endpoint, headers (including API key), and JSON body; executes and validates the response (throws on non-200 status).&lt;/li&gt;&lt;li&gt;&amp;#96;_parseLLMResponse&amp;#96;: Uses a switch statement based on &amp;#96;MODEL&amp;#96; to extract content; defaults to a placeholder if unsupported.&lt;/li&gt;&lt;/ul&gt;&#13;
&lt;/li&gt;&lt;/ol&gt;&#13;
&#13;
&lt;ol&gt;&lt;li&gt;**Storage**:&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;&amp;#96;_storeDocumentation&amp;#96;: Queries for existing documentation by reference; updates if found, or inserts a new record with name, reference, type, markdown, and timestamp. Returns a result object with title and link.&lt;/li&gt;&lt;/ul&gt;&#13;
&lt;/li&gt;&lt;/ol&gt;&#13;
&#13;
&lt;ol&gt;&lt;li&gt;**Utility Functions**:&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;&amp;#96;_setNestedValue&amp;#96;: Dynamically sets values in nested objects/arrays using dot notation (e.g., &amp;#39;messages[0].content&amp;#39;) with array index support.&lt;/li&gt;&lt;li&gt;&amp;#96;_simulateAPIResponse&amp;#96;: (Commented out) Provides mock responses for testing based on model.&lt;/li&gt;&lt;li&gt;&amp;#96;_createResponse&amp;#96;: Builds a simple JSON response with status and message.&lt;/li&gt;&lt;/ul&gt;&#13;
&lt;/li&gt;&lt;/ol&gt;&#13;
&#13;
&lt;ol&gt;&lt;li&gt;**Error Handling**:&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;Catches exceptions in try-catch blocks, logs errors via &amp;#96;gs.error&amp;#96;, and throws custom errors.&lt;/li&gt;&lt;li&gt;Propagation: Errors bubble up to prevent partial execution.&lt;/li&gt;&lt;/ul&gt;&#13;
&lt;/li&gt;&lt;/ol&gt;&#13;
&#13;
&lt;p&gt;The flow is sequential and synchronous, relying on GlideRecord for database operations and REST for API calls.&lt;/p&gt;&#13;
&#13;
&lt;h2&gt;Key Functionality&lt;/h2&gt;&#13;
&lt;ul&gt;&lt;li&gt;**LLM Integration**: Supports configurable LLM models with dynamic prompting and response parsing, allowing easy extension to new models via the switch statements.&lt;/li&gt;&lt;li&gt;**Prompt Construction**: Automatically filters out system fields (e.g., those prefixed with &amp;#39;sys_&amp;#39;) and formats the record as JSON within a markdown-wrapped prompt, ensuring focused and relevant documentation generation.&lt;/li&gt;&lt;li&gt;**API Request Formatting**: Uses &amp;#96;_setNestedValue&amp;#96; for flexible insertion of prompts into complex JSON structures (e.g., array-based message formats), making it adaptable to various LLM API schemas.&lt;/li&gt;&lt;li&gt;**Documentation Storage**: Persists generated markdown in a custom table (&amp;#96;u_docugen_code_docs&amp;#96;), with update/insert logic and timestamping for versioning.&lt;/li&gt;&lt;li&gt;**Debugging Support**: When &amp;#96;DEBUG&amp;#96; is true, collects intermediate results (e.g., prompt, response) into an array for detailed output, aiding development and troubleshooting.&lt;/li&gt;&lt;li&gt;**Error Resilience**: Comprehensive try-catch blocks and logging ensure failures are handled gracefully without crashing the process.&lt;/li&gt;&lt;li&gt;**Extensibility**: Model-specific handling in parsing and simulation allows for adding support for new LLMs (e.g., &amp;#39;chatgpt&amp;#39;, &amp;#39;claude&amp;#39;, &amp;#39;mistral&amp;#39;) with minimal code changes.&lt;/li&gt;&lt;li&gt;**Security and Isolation**: As a public, client-callable Script Include, it uses ServiceNow&amp;#39;s RESTMessageV2 for secure API calls and isolates operations via GlideRecord.&lt;/li&gt;&lt;/ul&gt;&#13;
&#13;
&lt;p&gt;This Script Include is designed for scalability in documentation automation within ServiceNow environments, particularly for codebases requiring consistent, AI-generated docs.&lt;/p&gt;&lt;/div&gt;]]&gt;&lt;/u_documentation&gt;&#13;
&lt;u_documentation_markdown&gt;# Documentation for Script Include: DocuGenLLMClientUtils&#13;
&#13;
## Overview&#13;
This is a ServiceNow Script Include that defines a client-callable AJAX processor for generating documentation using Large Language Models (LLMs). It is configured to be active, publicly accessible, and client-callable, but not mobile-callable or sandbox-callable. The class extends `global.AbstractAjaxProcessor` to handle AJAX requests. It integrates with external LLM APIs to automatically generate markdown-formatted documentation for ServiceNow scripts based on their attributes.&#13;
&#13;
## Purpose&#13;
The primary purpose of this Script Include is to automate the generation of detailed documentation for ServiceNow records (e.g., scripts) by leveraging LLMs. It fetches configuration from a models table, constructs a prompt with the record's non-system fields, sends it to an LLM API, parses the response, and stores the resulting documentation in a dedicated table. This facilitates documentation generation for development and maintenance, with built-in error handling, debugging support, and model-specific parsing. It supports multiple LLM models (e.g., Grok, ChatGPT, Claude) and ensures data integrity by ignoring system fields.&#13;
&#13;
## Parameters&#13;
The Script Include is structured as a class with an `initialize` method and several public and private methods. Key parameters across methods include:&#13;
&#13;
- **initialize(model=null)**: &#13;
  - `model` (String, optional): The name of the LLM model to use from the `u_models` table. If not provided, it queries for the default model (where `u_default` is true).&#13;
&#13;
- **generateDocumentation(recordSysId, recordDisplayValue, tableName, modelRecordName=null)**:&#13;
  - `recordSysId` (String): The sys_id of the record (e.g., script) to generate documentation for.&#13;
  - `recordDisplayValue` (String): The display value (e.g., name) of the record.&#13;
  - `tableName` (String): The table name of the record (e.g., `sys_script_include`).&#13;
  - `modelRecordName` (String, optional): An alternative model name to override the initialized one.&#13;
&#13;
Private methods have internal parameters derived from the public ones or class properties, such as prompts, API endpoints, and response objects. No explicit parameters are exposed for client-side calls beyond those in `generateDocumentation`, as it is the main entry point.&#13;
&#13;
## Logic Flow&#13;
The Script Include operates as an AJAX processor, with logic centered around the `generateDocumentation` method. Below is a step-by-step breakdown of the overall flow:&#13;
&#13;
1. **Initialization**:&#13;
   - Sets debug mode (`DEBUG = true`) and constants (e.g., `DOCS_TABLE = 'u_docugen_code_docs'`).&#13;
   - Queries the `u_models` table for the specified or default model.&#13;
   - Loads model configuration (e.g., `LLMENDPOINT`, `APIKEY`, `APIPROMPT`, `MODEL`).&#13;
   - Defines status codes (e.g., `SUCCESS: 200`).&#13;
   - Throws an error if no model is found.&#13;
&#13;
2. **Generate Documentation (Main Method)**:&#13;
   - Checks for initialization errors.&#13;
   - Builds a prompt using `_buildPrompt`, which retrieves the record, extracts non-system fields into a JSON object, and formats a markdown prompt.&#13;
   - Formats the API request using `_formatRequest`, which parses `APIPROMPT` and sets the prompt into a nested structure via `_setNestedValue`.&#13;
   - Calls the LLM API using `_callLLMAPI` (or simulates in debug mode, though commented out).&#13;
   - Parses the response using `_parseLLMResponse`, handling model-specific formats (e.g., for 'grok', extracts `choices[0].message.content`).&#13;
   - Stores the documentation using `_storeDocumentation`, updating or inserting into `u_docugen_code_docs`.&#13;
   - Returns a response object with status and message (includes debug array if `DEBUG` is true).&#13;
&#13;
3. **API Call and Parsing**:&#13;
   - `_callLLMAPI`: Configures a REST message with endpoint, headers (including API key), and JSON body; executes and validates the response (throws on non-200 status).&#13;
   - `_parseLLMResponse`: Uses a switch statement based on `MODEL` to extract content; defaults to a placeholder if unsupported.&#13;
&#13;
4. **Storage**:&#13;
   - `_storeDocumentation`: Queries for existing documentation by reference; updates if found, or inserts a new record with name, reference, type, markdown, and timestamp. Returns a result object with title and link.&#13;
&#13;
5. **Utility Functions**:&#13;
   - `_setNestedValue`: Dynamically sets values in nested objects/arrays using dot notation (e.g., 'messages[0].content') with array index support.&#13;
   - `_simulateAPIResponse`: (Commented out) Provides mock responses for testing based on model.&#13;
   - `_createResponse`: Builds a simple JSON response with status and message.&#13;
&#13;
6. **Error Handling**:&#13;
   - Catches exceptions in try-catch blocks, logs errors via `gs.error`, and throws custom errors.&#13;
   - Propagation: Errors bubble up to prevent partial execution.&#13;
&#13;
The flow is sequential and synchronous, relying on GlideRecord for database operations and REST for API calls.&#13;
&#13;
## Key Functionality&#13;
- **LLM Integration**: Supports configurable LLM models with dynamic prompting and response parsing, allowing easy extension to new models via the switch statements.&#13;
- **Prompt Construction**: Automatically filters out system fields (e.g., those prefixed with 'sys_') and formats the record as JSON within a markdown-wrapped prompt, ensuring focused and relevant documentation generation.&#13;
- **API Request Formatting**: Uses `_setNestedValue` for flexible insertion of prompts into complex JSON structures (e.g., array-based message formats), making it adaptable to various LLM API schemas.&#13;
- **Documentation Storage**: Persists generated markdown in a custom table (`u_docugen_code_docs`), with update/insert logic and timestamping for versioning.&#13;
- **Debugging Support**: When `DEBUG` is true, collects intermediate results (e.g., prompt, response) into an array for detailed output, aiding development and troubleshooting.&#13;
- **Error Resilience**: Comprehensive try-catch blocks and logging ensure failures are handled gracefully without crashing the process.&#13;
- **Extensibility**: Model-specific handling in parsing and simulation allows for adding support for new LLMs (e.g., 'chatgpt', 'claude', 'mistral') with minimal code changes.&#13;
- **Security and Isolation**: As a public, client-callable Script Include, it uses ServiceNow's RESTMessageV2 for secure API calls and isolates operations via GlideRecord.&#13;
&#13;
This Script Include is designed for scalability in documentation automation within ServiceNow environments, particularly for codebases requiring consistent, AI-generated docs.&lt;/u_documentation_markdown&gt;&#13;
&lt;u_name&gt;DocuGenLLMClientUtils&lt;/u_name&gt;&#13;
&lt;u_script_reference display_value="DocuGenLLMClientUtils"&gt;b5441bbb83f7621046cfe4d0deaad3a4&lt;/u_script_reference&gt;&#13;
&lt;u_script_type&gt;sys_script_include&lt;/u_script_type&gt;&#13;
&lt;/u_docugen_code_docs&gt;&#13;
&lt;/unload&gt;</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2025-09-13 04:31:45</sys_created_on>
        <sys_id>6dbd1e888308b21046cfe4d0deaad307</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name/>
        <sys_package display_value="DocuGenLLM" source="54a6cf7783b7621046cfe4d0deaad30f">54a6cf7783b7621046cfe4d0deaad30f</sys_package>
        <sys_policy/>
        <sys_scope display_value="DocuGenLLM">54a6cf7783b7621046cfe4d0deaad30f</sys_scope>
        <sys_update_name>sys_metadata_link_6dbd1e888308b21046cfe4d0deaad307</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-09-13 04:31:45</sys_updated_on>
        <tablename>u_docugen_code_docs</tablename>
    </sys_metadata_link>
</record_update>
